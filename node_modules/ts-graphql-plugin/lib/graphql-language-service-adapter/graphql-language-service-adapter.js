"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLLanguageServiceAdapter = void 0;
const typescript_1 = __importDefault(require("typescript"));
const graphql_1 = require("graphql");
const ts_ast_util_1 = require("../ts-ast-util");
const gql_ast_util_1 = require("../gql-ast-util");
const get_completion_at_position_1 = require("./get-completion-at-position");
const get_semantic_diagonistics_1 = require("./get-semantic-diagonistics");
const get_quick_info_at_position_1 = require("./get-quick-info-at-position");
class GraphQLLanguageServiceAdapter {
    constructor(_helper, opt) {
        this._helper = _helper;
        this._logger = () => { };
        if (opt.logger)
            this._logger = opt.logger;
        if (opt.schemaErrors)
            this.updateSchema(opt.schemaErrors, null);
        if (opt.schema)
            this.updateSchema(null, opt.schema);
        if (opt.tag)
            this._tagCondition = opt.tag;
        this._removeDuplicatedFragments = opt.removeDuplicatedFragments;
        this._analysisContext = this._createAnalysisContext();
    }
    getCompletionAtPosition(delegate, ...args) {
        return (0, get_completion_at_position_1.getCompletionAtPosition)(this._analysisContext, delegate, ...args);
    }
    getSemanticDiagnostics(delegate, ...args) {
        return (0, get_semantic_diagonistics_1.getSemanticDiagnostics)(this._analysisContext, delegate, ...args);
    }
    getQuickInfoAtPosition(delegate, ...args) {
        return (0, get_quick_info_at_position_1.getQuickInfoAtPosition)(this._analysisContext, delegate, ...args);
    }
    updateSchema(errors, schema) {
        if (errors) {
            this._schemaErrors = errors;
            this._schema = null;
        }
        else {
            this._schema = schema;
            this._schemaErrors = null;
        }
    }
    _createAnalysisContext() {
        const ctx = {
            debug: msg => this._logger(msg),
            getScriptSourceHelper: () => this._helper,
            getSchema: () => this._schema,
            getSchemaOrSchemaErrors: () => {
                if (!this._schema) {
                    return [null, this._schemaErrors];
                }
                else {
                    return [this._schema, null];
                }
            },
            findTemplateNode: (fileName, position) => this._findTemplateNode(fileName, position),
            findTemplateNodes: fileName => this._findTemplateNodes(fileName),
            resolveTemplateInfo: (fileName, node) => this._resolveTemplateInfo(fileName, node),
        };
        return ctx;
    }
    _findTemplateNode(fileName, position) {
        const foundNode = this._helper.getNode(fileName, position);
        if (!foundNode)
            return;
        let node;
        if (typescript_1.default.isNoSubstitutionTemplateLiteral(foundNode)) {
            node = foundNode;
        }
        else if (typescript_1.default.isTemplateHead(foundNode) && !(0, ts_ast_util_1.isTemplateLiteralTypeNode)(foundNode.parent)) {
            node = foundNode.parent;
        }
        else if ((typescript_1.default.isTemplateMiddle(foundNode) || typescript_1.default.isTemplateTail(foundNode)) &&
            !(0, ts_ast_util_1.isTemplateLiteralTypeNode)(foundNode.parent.parent)) {
            node = foundNode.parent.parent;
        }
        else {
            return;
        }
        if (this._tagCondition && !(0, ts_ast_util_1.isTagged)(node, this._tagCondition)) {
            return;
        }
        return node;
    }
    _findTemplateNodes(fileName) {
        const allTemplateStringNodes = this._helper.getAllNodes(fileName, (n) => typescript_1.default.isNoSubstitutionTemplateLiteral(n) || typescript_1.default.isTemplateExpression(n));
        const nodes = allTemplateStringNodes.filter(n => {
            if (!this._tagCondition)
                return true;
            return (0, ts_ast_util_1.isTagged)(n, this._tagCondition);
        });
        return nodes;
    }
    _resolveTemplateInfo(fileName, node) {
        const { resolvedInfo, resolveErrors } = this._helper.resolveTemplateLiteral(fileName, node);
        if (!resolvedInfo)
            return { resolveErrors };
        if (!this._removeDuplicatedFragments)
            return { resolveErrors, resolvedInfo };
        try {
            const documentNode = (0, graphql_1.parse)(resolvedInfo.combinedText);
            const duplicatedFragmentInfoList = (0, gql_ast_util_1.detectDuplicatedFragments)(documentNode);
            const info = duplicatedFragmentInfoList.reduce((acc, fragmentInfo) => {
                return this._helper.updateTemplateLiteralInfo(acc, fragmentInfo);
            }, resolvedInfo);
            return { resolvedInfo: info, resolveErrors };
        }
        catch (error) {
            // Note:
            // `parse` throws GraphQL syntax error when combinedText is invalid for GraphQL syntax.
            // We don't need handle this error because getDiagnostics method in this class re-checks syntax with graphql-lang-service,
            return { resolvedInfo, resolveErrors };
        }
    }
}
exports.GraphQLLanguageServiceAdapter = GraphQLLanguageServiceAdapter;
//# sourceMappingURL=graphql-language-service-adapter.js.map