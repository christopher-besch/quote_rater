"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSemanticDiagnostics = void 0;
const typescript_1 = __importDefault(require("typescript"));
const graphql_language_service_interface_1 = require("graphql-language-service-interface");
const errors_1 = require("../errors");
function createSchemaErrorDiagnostic(errorInfo, file, start, length) {
    let messageText = `[ts-graphql-plugin] Schema build error: '${errorInfo.message}' `;
    if (errorInfo.fileName) {
        messageText += `Check ${errorInfo.fileName}`;
        if (errorInfo.locations && errorInfo.locations[0]) {
            messageText += `[${errorInfo.locations[0].line + 1}:${errorInfo.locations[0].character + 1}]`;
        }
    }
    const category = typescript_1.default.DiagnosticCategory.Error;
    const code = errors_1.ERROR_CODES.schemaBuildError.code;
    return { category, code, messageText, file, start, length };
}
function createIsInOtherExpressionDiagnostic(file, start, length) {
    const category = typescript_1.default.DiagnosticCategory.Error;
    const code = errors_1.ERROR_CODES.errorInOtherInterpolation.code;
    const messageText = errors_1.ERROR_CODES.errorInOtherInterpolation.message;
    return { category, code, messageText, file, start, length };
}
function translateDiagnostic(d, file, start, length) {
    const category = d.severity === 2 ? typescript_1.default.DiagnosticCategory.Warning : typescript_1.default.DiagnosticCategory.Error;
    const code = errors_1.ERROR_CODES.graphqlLangServiceError.code;
    const messageText = d.message.split('\n')[0];
    return { code, messageText, category, file, start, length };
}
function getSemanticDiagnostics(ctx, delegate, fileName) {
    const errors = delegate(fileName) || [];
    const nodes = ctx.findTemplateNodes(fileName);
    const result = [...errors];
    const [schema, schemaErrors] = ctx.getSchemaOrSchemaErrors();
    if (schemaErrors) {
        nodes.forEach(node => {
            schemaErrors.forEach(schemaErrorInfo => {
                const file = node.getSourceFile();
                const start = node.getStart();
                const lengrh = node.getWidth();
                result.push(createSchemaErrorDiagnostic(schemaErrorInfo, file, start, lengrh));
            });
        });
    }
    else if (schema) {
        const diagnosticsAndResolvedInfoList = nodes.map(n => {
            const { resolvedInfo, resolveErrors } = ctx.resolveTemplateInfo(fileName, n);
            return {
                resolveErrors,
                resolvedTemplateInfo: resolvedInfo,
                diagnostics: resolvedInfo ? (0, graphql_language_service_interface_1.getDiagnostics)(resolvedInfo.combinedText, schema) : [],
            };
        });
        diagnosticsAndResolvedInfoList.forEach((info, i) => {
            const node = nodes[i];
            if (!info.resolvedTemplateInfo) {
                info.resolveErrors
                    .filter(re => re.fileName === fileName)
                    .forEach(resolveError => {
                    result.push({
                        category: typescript_1.default.DiagnosticCategory.Warning,
                        code: errors_1.ERROR_CODES.templateIsTooComplex.code,
                        messageText: errors_1.ERROR_CODES.templateIsTooComplex.message,
                        file: node.getSourceFile(),
                        start: resolveError.start,
                        length: resolveError.end,
                    });
                });
                return;
            }
            const { diagnostics, resolvedTemplateInfo: { getSourcePosition, convertInnerLocation2InnerPosition }, } = info;
            diagnostics.forEach(d => {
                let length = 0;
                const file = node.getSourceFile();
                const { pos: startPositionOfSource, isInOtherExpression } = getSourcePosition(convertInnerLocation2InnerPosition(d.range.start));
                try {
                    const endPositionOfSource = getSourcePosition(convertInnerLocation2InnerPosition(d.range.end)).pos;
                    length = endPositionOfSource - startPositionOfSource - 1;
                }
                catch (error) {
                    length = 0;
                }
                if (isInOtherExpression) {
                    result.push(createIsInOtherExpressionDiagnostic(file, startPositionOfSource, length));
                }
                else {
                    result.push(translateDiagnostic(d, file, startPositionOfSource, length));
                }
            });
        });
    }
    return result;
}
exports.getSemanticDiagnostics = getSemanticDiagnostics;
//# sourceMappingURL=get-semantic-diagonistics.js.map