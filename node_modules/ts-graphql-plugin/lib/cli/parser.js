"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createParser = void 0;
const path_1 = __importDefault(require("path"));
const string_util_1 = require("../string-util");
function parseRaw(argv) {
    if (!argv.length) {
        return {
            subCommandName: null,
            args: [],
            rawOptions: [],
        };
    }
    const rawOptions = [];
    let subCommandName = undefined;
    let i = 0;
    if (argv[0][0] !== '-') {
        subCommandName = argv[0];
        i++;
    }
    const args = [];
    while (i < argv.length) {
        const current = argv[i];
        i++;
        if (current[0] === '-') {
            let isShort;
            let optName;
            let optStrVal = undefined;
            if (current[1] !== '-') {
                isShort = true;
                optName = current.slice(1);
            }
            else {
                isShort = false;
                optName = current.slice(2);
            }
            const idx = optName.indexOf('=');
            if (idx !== -1) {
                optStrVal = optName.slice(idx + 1);
                optName = optName.slice(0, idx);
            }
            else if (argv[i] && argv[i][0] !== '-') {
                optStrVal = argv[i];
                i++;
            }
            rawOptions.push({
                isShort,
                optName,
                optStrVal,
            });
        }
        else {
            args.push(current);
        }
    }
    return {
        args,
        subCommandName,
        rawOptions,
    };
}
function createParser(parseOptions) {
    const { logger } = parseOptions;
    const parse = (rawArguments = process.argv) => {
        const showHelp = () => {
            const lines = [];
            lines.push(`Usage: ${path_1.default.basename(rawArguments[1])} <command> [options]`);
            lines.push('');
            lines.push('available commands are:');
            lines.push(`    ${Object.keys(parseOptions.commands).join(', ')}`);
            lines.push('');
            lines.push('Options:');
            let line = '';
            Object.entries(parseOptions.options).forEach(([name, value]) => {
                line = ' ';
                if (value.alias) {
                    line += `-${value.alias}, `;
                }
                line += `--${name}`;
                if (value.description) {
                    line += (0, string_util_1.pad)(' ', 42 - line.length) + value.description;
                }
                if ('defaultValue' in value) {
                    line += ` [default: ${value.defaultValue + ''}]`;
                }
                lines.push(line);
            });
            logger.info(lines.join('\n'));
        };
        const showCommandHelp = (commandName) => {
            const lines = [];
            lines.push(`Usage: ${path_1.default.basename(rawArguments[1])} ${commandName} [options]`);
            lines.push('');
            lines.push(`Description: ${parseOptions.commands[commandName].description}`);
            lines.push('');
            lines.push('Options:');
            let line = '';
            Object.entries(parseOptions.commands[commandName].options).forEach(([name, value]) => {
                line = ' ';
                if (value.alias) {
                    line += `-${value.alias}, `;
                }
                line += `--${name}`;
                if (value.description) {
                    line += (0, string_util_1.pad)(' ', 42 - line.length) + value.description;
                }
                if ('defaultValue' in value) {
                    line += `  [default: ${value.defaultValue + ''}]`;
                }
                lines.push(line);
            });
            logger.info(lines.join('\n'));
        };
        const availableCommandNames = () => {
            return Object.keys(parseOptions.commands);
        };
        const argv = rawArguments.slice(2);
        const { args, subCommandName, rawOptions } = parseRaw(argv);
        const getOptions = (x) => {
            const options = {};
            Object.entries(x.options).forEach(([k, v]) => {
                let hit;
                if (v.alias)
                    hit = rawOptions.find(x => x.optName === v.alias && x.isShort);
                if (!hit)
                    hit = rawOptions.find(x => x.optName === k && !x.isShort);
                if (hit) {
                    let value;
                    if (v.type === 'boolean') {
                        value = true;
                    }
                    else if (v.type === 'string') {
                        value = hit.optStrVal;
                    }
                    else if (v.type === 'int') {
                        value = +(hit.optStrVal || '0');
                    }
                    options[k] = value;
                }
                else if ('defaultValue' in v) {
                    options[k] = v.defaultValue;
                }
                else if (v.type === 'boolean') {
                    options[k] = false;
                }
                else if (v.type === 'string') {
                    options[k] = '';
                }
                else if (v.type === 'int') {
                    options[k] = 0;
                }
            });
            return options;
        };
        const baseOptions = getOptions(parseOptions);
        const funcs = {
            showHelp,
            showCommandHelp,
            availableCommandNames,
        };
        if (!subCommandName) {
            return {
                _: args,
                options: baseOptions,
                ...funcs,
            };
        }
        else if (!parseOptions.commands[subCommandName]) {
            return {
                _: args,
                options: baseOptions,
                errors: {
                    unknownCommand: subCommandName,
                },
                ...funcs,
            };
        }
        else {
            return {
                _: [],
                options: baseOptions,
                command: {
                    [subCommandName]: {
                        _: args,
                        options: getOptions(parseOptions.commands[subCommandName]),
                    },
                },
                ...funcs,
            };
        }
    };
    return {
        parse,
    };
}
exports.createParser = createParser;
//# sourceMappingURL=parser.js.map