"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createImportSpecifier = exports.isTsVersionLaterThanOrEqualTo = exports.removeAliasFromImportDeclaration = exports.mergeImportDeclarationsWithSameModules = exports.isImportDeclarationWithCondition = exports.isTemplateLiteralTypeNode = exports.isTagged = exports.hasTagged = exports.findAllNodes = exports.findNode = void 0;
const typescript_1 = __importDefault(require("typescript"));
function mergeNamedBinding(base, head) {
    if (!base && !head)
        return undefined;
    if (!base)
        return head;
    if (!head)
        return base;
    // treat namedImports only
    if (typescript_1.default.isNamespaceImport(base) || typescript_1.default.isNamespaceImport(head))
        return base;
    return typescript_1.default.updateNamedImports(base, [...base.elements, ...head.elements]);
}
function removeFromNamedBinding(base, name) {
    if (!base)
        return undefined;
    // treat namedImports only
    if (typescript_1.default.isNamespaceImport(base))
        return base;
    const elements = base.elements.filter(elm => elm.name.text !== name);
    if (elements.length === 0)
        return undefined;
    return typescript_1.default.updateNamedImports(base, elements);
}
function mergeImportClause(base, head) {
    if (!base && !head)
        return undefined;
    if (!base)
        return head;
    if (!head)
        return base;
    const name = head.name || base.name;
    const namedBindings = mergeNamedBinding(base.namedBindings, head.namedBindings);
    const isTypeOnly = base.isTypeOnly && head.isTypeOnly;
    return typescript_1.default.updateImportClause(base, name, namedBindings, isTypeOnly);
}
function removeFromImportClause(base, name) {
    var _a;
    if (!base)
        return undefined;
    const namedBindings = removeFromNamedBinding(base.namedBindings, name);
    const nameId = ((_a = base.name) === null || _a === void 0 ? void 0 : _a.text) !== name ? base.name : undefined;
    if (!nameId && !namedBindings)
        return undefined;
    return typescript_1.default.updateImportClause(base, nameId, namedBindings, base.isTypeOnly);
}
function findNode(sourceFile, position) {
    function find(node) {
        if (position >= node.getStart() && position < node.getEnd()) {
            return typescript_1.default.forEachChild(node, find) || node;
        }
    }
    return find(sourceFile);
}
exports.findNode = findNode;
function findAllNodes(sourceFile, cond) {
    const result = [];
    function find(node) {
        if (cond(node)) {
            result.push(node);
            return;
        }
        else {
            typescript_1.default.forEachChild(node, find);
        }
    }
    find(sourceFile);
    return result;
}
exports.findAllNodes = findAllNodes;
function hasTagged(node, condition) {
    if (!node)
        return;
    if (!typescript_1.default.isTaggedTemplateExpression(node))
        return false;
    const tagNode = node;
    return tagNode.tag.getText() === condition;
}
exports.hasTagged = hasTagged;
function isTagged(node, condition) {
    if (!node)
        return false;
    return hasTagged(node.parent, condition);
}
exports.isTagged = isTagged;
function isTemplateLiteralTypeNode(node) {
    // ts.isNoSubstitutionTemplateLiteral exists TypeScript >= 4.1
    return typeof typescript_1.default.isTemplateLiteralTypeNode === 'function' && typescript_1.default.isTemplateLiteralTypeNode(node);
}
exports.isTemplateLiteralTypeNode = isTemplateLiteralTypeNode;
function isImportDeclarationWithCondition(node, { isDefault, name, from }) {
    var _a, _b;
    if (!name && !from)
        return false;
    if (!typescript_1.default.isImportDeclaration(node))
        return false;
    if (from) {
        if (!typescript_1.default.isStringLiteralLike(node.moduleSpecifier) || node.moduleSpecifier.text !== from)
            return false;
    }
    if (!name)
        return true;
    if (!node.importClause)
        return false;
    let result = false;
    if (isDefault !== false) {
        result = result || ((_a = node.importClause.name) === null || _a === void 0 ? void 0 : _a.text) === name;
    }
    if (isDefault !== true && node.importClause.namedBindings) {
        if (typescript_1.default.isNamedImports(node.importClause.namedBindings)) {
            result = result || node.importClause.namedBindings.elements.some(elm => { var _a; return ((_a = elm.name) === null || _a === void 0 ? void 0 : _a.text) === name; });
        }
        else if (typescript_1.default.isNamespaceImport(node.importClause.namedBindings)) {
            result = result || ((_b = node.importClause.namedBindings.name) === null || _b === void 0 ? void 0 : _b.text) === name;
        }
    }
    return result;
}
exports.isImportDeclarationWithCondition = isImportDeclarationWithCondition;
function mergeImportDeclarationsWithSameModules(base, head) {
    if (!typescript_1.default.isStringLiteralLike(base.moduleSpecifier) || !typescript_1.default.isStringLiteralLike(head.moduleSpecifier))
        return base;
    if (base.moduleSpecifier.text !== head.moduleSpecifier.text)
        return base;
    const decorators = head.decorators || base.decorators;
    const modifiers = head.modifiers || base.modifiers;
    const importClause = mergeImportClause(base.importClause, head.importClause);
    return typescript_1.default.updateImportDeclaration(base, decorators, modifiers, importClause, base.moduleSpecifier, undefined);
}
exports.mergeImportDeclarationsWithSameModules = mergeImportDeclarationsWithSameModules;
function removeAliasFromImportDeclaration(base, name) {
    const decorators = base.decorators;
    const modifiers = base.modifiers;
    const importClause = removeFromImportClause(base.importClause, name);
    if (!importClause)
        return undefined;
    return typescript_1.default.updateImportDeclaration(base, decorators, modifiers, importClause, base.moduleSpecifier, undefined);
}
exports.removeAliasFromImportDeclaration = removeAliasFromImportDeclaration;
function isTsVersionLaterThanOrEqualTo(major, minor) {
    var _a, _b, _c, _d;
    const m = typescript_1.default.versionMajorMinor.match(/(?<major>\d+)\.(?<minor>\d+)/);
    const actualMajor = parseInt((_b = (_a = m === null || m === void 0 ? void 0 : m.groups) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : '0', 10);
    const actualMinor = parseInt((_d = (_c = m === null || m === void 0 ? void 0 : m.groups) === null || _c === void 0 ? void 0 : _c.minor) !== null && _d !== void 0 ? _d : '0', 10);
    return actualMajor > major || (actualMajor === major && actualMinor >= minor);
}
exports.isTsVersionLaterThanOrEqualTo = isTsVersionLaterThanOrEqualTo;
/**
 * Typescript 4.5 adds an `isTypeOnly` argument as the first argument to
 * `ts.createImportSpecifier`. To avoid breaking compatibility with earlier
 * Typescript versions this helper checks the Typescript version to decide which
 * set of arguments to pass along.
 */
const createImportSpecifier = (isTypeOnly, ...rest) => {
    return isTsVersionLaterThanOrEqualTo(4, 5)
        ? typescript_1.default.createImportSpecifier(isTypeOnly, ...rest)
        : // @ts-ignore
            typescript_1.default.createImportSpecifier(...rest);
};
exports.createImportSpecifier = createImportSpecifier;
//# sourceMappingURL=utilily-functions.js.map