"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorReporter = void 0;
const path_1 = __importDefault(require("path"));
const _1 = require(".");
const string_util_1 = require("../string-util");
const lineMark = (line, width) => {
    const strLine = line + 1 + '';
    return string_util_1.color.invert((0, string_util_1.pad)(' ', width - strLine.length) + strLine) + ' ';
};
const lineMarkForUnderline = (width) => {
    return string_util_1.color.invert((0, string_util_1.pad)(' ', width)) + ' ';
};
class ErrorReporter {
    constructor(_currentDirectory, _output = () => { }) {
        this._currentDirectory = _currentDirectory;
        this._output = _output;
    }
    outputError(error) {
        if (error instanceof _1.ErrorWithoutLocation) {
            this._outputErrorWithoutLocation(error);
        }
        else if (error instanceof _1.ErrorWithLocation) {
            this._outputErrorWithLocation(error);
        }
    }
    _outputErrorWithoutLocation(error) {
        const prefix = error.severity === 'Error' ? string_util_1.color.red('error') : string_util_1.color.yellow('warn');
        this._output(prefix + ': ' + error.message);
    }
    _outputErrorWithLocation(error) {
        const { message, errorContent: { content, start, end, fileName }, } = error;
        const startLC = (0, string_util_1.pos2location)(content, start);
        const endLC = (0, string_util_1.pos2location)(content, end);
        const relativeContentPath = path_1.default.isAbsolute(fileName) ? path_1.default.relative(this._currentDirectory, fileName) : fileName;
        const fileIndicator = `${relativeContentPath}:${startLC.line + 1}:${startLC.character + 1}`;
        const outputs = [`${string_util_1.color.thin(fileIndicator)} - ${message}`, ''];
        const allLines = content.split('\n');
        const preLines = allLines.slice(Math.max(startLC.line - 1, 0), startLC.line);
        const lines = allLines.slice(startLC.line, endLC.line + 1);
        const postLines = allLines.slice(endLC.line + 1, Math.min(allLines.length - 1, endLC.line + 2));
        const lineMarkerWidth = (Math.min(allLines.length - 1, endLC.line + 2) + '').length;
        for (let i = 0; i < preLines.length; ++i) {
            outputs.push(lineMark(i + startLC.line - 1, lineMarkerWidth) + string_util_1.color.thin(preLines[i]));
        }
        for (let i = 0; i < lines.length; ++i) {
            outputs.push(lineMark(i + startLC.line, lineMarkerWidth) + lines[i]);
            if (i === 0) {
                if (startLC.line === endLC.line) {
                    outputs.push(lineMarkForUnderline(lineMarkerWidth) +
                        (0, string_util_1.pad)(' ', startLC.character) +
                        string_util_1.color.red((0, string_util_1.pad)('~', endLC.character - startLC.character)));
                }
                else {
                    outputs.push(lineMarkForUnderline(lineMarkerWidth) +
                        (0, string_util_1.pad)(' ', startLC.character) +
                        string_util_1.color.red((0, string_util_1.pad)('~', lines[i].length - startLC.character)));
                }
            }
            else if (i === lines.length - 1) {
                outputs.push(lineMarkForUnderline(lineMarkerWidth) + string_util_1.color.red((0, string_util_1.pad)('~', endLC.character)));
            }
            else {
                outputs.push(lineMarkForUnderline(lineMarkerWidth) + string_util_1.color.red((0, string_util_1.pad)('~', lines[i].length)));
            }
        }
        for (let i = 0; i < postLines.length; ++i) {
            outputs.push(lineMark(i + endLC.line + 1, lineMarkerWidth) + string_util_1.color.thin(postLines[i]));
        }
        outputs.push('');
        const result = outputs.join('\n');
        this._output(result);
        return result;
    }
}
exports.ErrorReporter = ErrorReporter;
//# sourceMappingURL=error-reporter.js.map