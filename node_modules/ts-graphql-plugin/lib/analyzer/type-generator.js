"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenerator = void 0;
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const errors_1 = require("../errors");
const typegen_1 = require("../typegen");
const string_util_1 = require("../string-util");
const ts_ast_util_1 = require("../ts-ast-util");
class TypeGenerator {
    constructor({ prjRootPath, extractor, tag, addonFactories, debug }) {
        this._prjRootPath = prjRootPath;
        this._extractor = extractor;
        this._tag = tag;
        this._addonFactories = addonFactories;
        this._debug = debug;
        this._printer = typescript_1.default.createPrinter({ newLine: typescript_1.default.NewLineKind.LineFeed, removeComments: false });
    }
    createAddon({ schema, extractedResult, outputSource, }) {
        const context = {
            schema,
            source: outputSource,
            extractedInfo: {
                fileName: extractedResult.fileName,
                tsTemplateNode: extractedResult.templateNode,
                tsSourceFile: extractedResult.templateNode.getSourceFile(),
            },
        };
        const addons = this._addonFactories.map(factory => factory(context));
        return { addon: (0, typegen_1.mergeAddons)(addons), context };
    }
    generateTypes({ files, schema }) {
        const extractedResults = this._extractor.extract(files, this._tag);
        const extractedErrors = this._extractor.pickupErrors(extractedResults);
        if (extractedErrors.length) {
            this._debug(`Found ${extractedErrors.length} extraction errors.`);
        }
        const typegenErrors = [];
        const visitor = new typegen_1.TypeGenVisitor({ schema });
        const outputSourceFiles = [];
        extractedResults.forEach(extractedResult => {
            if (extractedResult.documentNode) {
                const { type, fragmentName, operationName } = this._extractor.getDominantDefinition(extractedResult);
                if (type === 'complex') {
                    const fileName = extractedResult.fileName;
                    const content = extractedResult.templateNode.getSourceFile().getFullText();
                    const start = extractedResult.templateNode.getStart();
                    const end = extractedResult.templateNode.getEnd();
                    const errorContent = { fileName, content, start, end };
                    const error = new errors_1.ErrorWithLocation('This document node has complex operations.', errorContent);
                    typegenErrors.push(error);
                    return;
                }
                const operationOrFragmentName = type === 'fragment' ? fragmentName : operationName;
                if (!operationOrFragmentName)
                    return;
                const outputFileName = path_1.default.resolve(path_1.default.dirname(extractedResult.fileName), '__generated__', (0, string_util_1.dasherize)(operationOrFragmentName) + '.ts');
                try {
                    const outputSource = (0, ts_ast_util_1.createOutputSource)({ outputFileName });
                    const { addon } = this.createAddon({ schema, outputSource, extractedResult });
                    const outputSourceFile = visitor.visit(extractedResult.documentNode, { outputSource, addon });
                    const content = this._printer.printFile(outputSourceFile);
                    outputSourceFiles.push({ fileName: outputFileName, content });
                    this._debug(`Create type source file '${path_1.default.relative(this._prjRootPath, outputFileName)}' from '${path_1.default.relative(this._prjRootPath, extractedResult.fileName)}'.`);
                }
                catch (error) {
                    if (error instanceof typegen_1.TypeGenError) {
                        const sourcePosition = extractedResult.resolevedTemplateInfo.getSourcePosition(error.node.loc.start);
                        if (sourcePosition.isInOtherExpression)
                            return;
                        const fileName = extractedResult.fileName;
                        const content = extractedResult.templateNode.getSourceFile().getFullText();
                        const start = sourcePosition.pos;
                        const end = extractedResult.resolevedTemplateInfo.getSourcePosition(error.node.loc.end).pos;
                        const errorContent = { fileName, content, start, end };
                        const translatedError = new errors_1.ErrorWithLocation(error.message, errorContent);
                        typegenErrors.push(translatedError);
                    }
                    else {
                        throw error;
                    }
                }
            }
        });
        return { errors: [...extractedErrors, ...typegenErrors], outputSourceFiles };
    }
}
exports.TypeGenerator = TypeGenerator;
//# sourceMappingURL=type-generator.js.map