"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Analyzer = exports.convertSchemaBuildErrorsToErrorWithLocation = void 0;
const typescript_1 = __importDefault(require("typescript"));
const path_1 = __importDefault(require("path"));
const extractor_1 = require("./extractor");
const ts_ast_util_1 = require("../ts-ast-util");
const errors_1 = require("../errors");
const string_util_1 = require("../string-util");
const validator_1 = require("./validator");
const markdown_reporter_1 = require("./markdown-reporter");
const type_generator_1 = require("./type-generator");
class TsGqlConfigError extends errors_1.ErrorWithoutLocation {
    constructor() {
        const message = 'No GraphQL schema. Confirm your ts-graphql-plugin\'s "schema" configuration at tsconfig.json\'s compilerOptions.plugins section.';
        super(message);
    }
}
function convertSchemaBuildErrorsToErrorWithLocation(errorInfo) {
    const fileName = errorInfo.fileName;
    const content = errorInfo.fileContent;
    if (errorInfo.locations && errorInfo.locations[0]) {
        const start = (0, string_util_1.location2pos)(errorInfo.fileContent, errorInfo.locations[0]);
        const end = start + 1;
        const errorContent = { fileName, content, start, end };
        return new errors_1.ErrorWithLocation(errorInfo.message, errorContent);
    }
    else {
        const start = 0;
        const end = content.length - 1;
        const errorContent = { fileName, content, start, end };
        return new errors_1.ErrorWithLocation(errorInfo.message, errorContent);
    }
}
exports.convertSchemaBuildErrorsToErrorWithLocation = convertSchemaBuildErrorsToErrorWithLocation;
class Analyzer {
    constructor(_pluginConfig, _prjRootPath, _languageServiceHost, _schemaManager, _debug) {
        this._pluginConfig = _pluginConfig;
        this._prjRootPath = _prjRootPath;
        this._languageServiceHost = _languageServiceHost;
        this._schemaManager = _schemaManager;
        this._debug = _debug;
        const langService = typescript_1.default.createLanguageService(this._languageServiceHost);
        this._scriptSourceHelper = (0, ts_ast_util_1.createScriptSourceHelper)({
            languageService: langService,
            languageServiceHost: this._languageServiceHost,
        });
        this._extractor = new extractor_1.Extractor({
            removeDuplicatedFragments: this._pluginConfig.removeDuplicatedFragments === false ? false : true,
            scriptSourceHelper: this._scriptSourceHelper,
            debug: this._debug,
        });
        this._typeGenerator = new type_generator_1.TypeGenerator({
            prjRootPath: this._prjRootPath,
            extractor: this._extractor,
            tag: this._pluginConfig.tag,
            addonFactories: this._pluginConfig.typegen.addonFactories,
            debug: this._debug,
        });
    }
    getPluginConfig() {
        return this._pluginConfig;
    }
    extract(fileNameList) {
        const results = this._extractor.extract(fileNameList || this._languageServiceHost.getScriptFileNames(), this._pluginConfig.tag);
        const errors = this._extractor.pickupErrors(results);
        return [errors, results];
    }
    extractToManifest() {
        const [errors, results] = this.extract();
        const manifest = this._extractor.toManifest(results, this._pluginConfig.tag);
        return [errors, manifest];
    }
    async validate() {
        const [schemaErrors, schema] = await this._getSchema();
        if (!schema)
            return { errors: schemaErrors };
        const [extractedErrors, results] = this.extract();
        if (extractedErrors.length) {
            this._debug(`Found ${extractedErrors.length} extraction errors.`);
        }
        return {
            errors: [...schemaErrors, ...extractedErrors, ...(0, validator_1.validate)(results, schema)],
            extractedResults: results,
            schema,
        };
    }
    report(outputFileName, manifest, ignoreFragments = true) {
        const reporter = new markdown_reporter_1.MarkdownReporter();
        const reportOptions = {
            baseDir: this._prjRootPath,
            ignoreFragments,
            outputDir: path_1.default.dirname(outputFileName),
        };
        if (manifest) {
            return [[], reporter.toMarkdownConntent(manifest, reportOptions)];
        }
        else {
            const [errors, extractedManifest] = this.extractToManifest();
            return [errors, reporter.toMarkdownConntent(extractedManifest, reportOptions)];
        }
    }
    async typegen() {
        const [schemaErrors, schema] = await this._getSchema();
        if (!schema)
            return { errors: schemaErrors };
        const { errors, outputSourceFiles } = this._typeGenerator.generateTypes({
            schema,
            files: this._languageServiceHost.getScriptFileNames(),
        });
        return { errors: [...schemaErrors, ...errors], outputSourceFiles };
    }
    async _getSchema() {
        const errors = [];
        const { schema, errors: schemaBuildErrors } = await this._schemaManager.waitSchema();
        if (schemaBuildErrors) {
            schemaBuildErrors.forEach(info => errors.push(convertSchemaBuildErrorsToErrorWithLocation(info)));
        }
        if (!schema && !errors.length) {
            errors.push(new TsGqlConfigError());
        }
        return [errors, schema];
    }
}
exports.Analyzer = Analyzer;
//# sourceMappingURL=analyzer.js.map