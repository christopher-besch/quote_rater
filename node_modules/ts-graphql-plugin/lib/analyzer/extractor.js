"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Extractor = void 0;
const typescript_1 = __importDefault(require("typescript"));
const graphql_1 = require("graphql");
const language_1 = require("graphql/language");
const ts_ast_util_1 = require("../ts-ast-util");
const errors_1 = require("../errors");
const gql_ast_util_1 = require("../gql-ast-util");
class Extractor {
    constructor({ debug, removeDuplicatedFragments, scriptSourceHelper }) {
        this._removeDuplicatedFragments = removeDuplicatedFragments;
        this._helper = scriptSourceHelper;
        this._debug = debug;
    }
    extract(files, tagName) {
        const results = [];
        this._debug('Extract template literals from: ');
        this._debug(files.map(f => ' ' + f).join(',\n'));
        files.forEach(fileName => {
            const nodes = this._helper
                .getAllNodes(fileName, node => typescript_1.default.isTemplateExpression(node) || typescript_1.default.isNoSubstitutionTemplateLiteral(node))
                .filter(node => (tagName ? (0, ts_ast_util_1.isTagged)(node, tagName) : true));
            nodes.forEach(node => {
                const { resolvedInfo, resolveErrors } = this._helper.resolveTemplateLiteral(fileName, node);
                if (!resolvedInfo) {
                    resolveErrors
                        .filter(re => re.fileName === fileName)
                        .forEach(resolveError => {
                        results.push({
                            fileName,
                            templateNode: node,
                            resolveTemplateError: {
                                message: errors_1.ERROR_CODES.templateIsTooComplex.message,
                                start: resolveError.start,
                                end: resolveError.end,
                            },
                            resolevedTemplateInfo: undefined,
                            graphqlError: undefined,
                            documentNode: undefined,
                        });
                    });
                }
                else {
                    results.push({
                        fileName,
                        templateNode: node,
                        resolevedTemplateInfo: resolvedInfo,
                    });
                }
            });
        });
        return results.map(result => {
            if (!result.resolevedTemplateInfo)
                return result;
            try {
                const rawDocumentNode = (0, graphql_1.parse)(result.resolevedTemplateInfo.combinedText);
                if (!this._removeDuplicatedFragments) {
                    return {
                        ...result,
                        documentNode: rawDocumentNode,
                    };
                }
                const duplicatedInfo = (0, gql_ast_util_1.detectDuplicatedFragments)(rawDocumentNode);
                const updatedResolvedInfo = duplicatedInfo.reduce((acc, fragmentInfo) => this._helper.updateTemplateLiteralInfo(acc, fragmentInfo), result.resolevedTemplateInfo);
                const documentNode = (0, graphql_1.parse)(updatedResolvedInfo.combinedText);
                return {
                    ...result,
                    documentNode,
                    resolevedTemplateInfo: updatedResolvedInfo,
                };
            }
            catch (error) {
                if (error instanceof graphql_1.GraphQLError) {
                    return {
                        ...result,
                        graphqlError: error,
                    };
                }
                else {
                    throw error;
                }
            }
        });
    }
    pickupErrors(extractResults, { ignoreGraphQLError } = { ignoreGraphQLError: false }) {
        const errors = [];
        extractResults.forEach(r => {
            if (r.resolveTemplateError) {
                errors.push(new errors_1.ErrorWithLocation(r.resolveTemplateError.message, {
                    fileName: r.fileName,
                    severity: 'Warn',
                    content: r.templateNode.getSourceFile().getFullText(),
                    start: r.resolveTemplateError.start,
                    end: r.resolveTemplateError.end,
                }));
            }
            else if (!ignoreGraphQLError && r.graphqlError) {
                const innerLoc = r.graphqlError.locations && r.graphqlError.locations[0];
                if (!innerLoc) {
                    errors.push(new errors_1.ErrorWithLocation(r.graphqlError.message, {
                        fileName: r.fileName,
                        content: r.templateNode.getSourceFile().getFullText(),
                        start: r.templateNode.getStart(),
                        end: r.templateNode.getEnd(),
                    }));
                }
                else if (r.resolevedTemplateInfo) {
                    const info = r.resolevedTemplateInfo;
                    const innerPosition = info.convertInnerLocation2InnerPosition({
                        line: innerLoc.line - 1,
                        character: innerLoc.column - 1,
                    });
                    const start = info.getSourcePosition(innerPosition).pos;
                    errors.push(new errors_1.ErrorWithLocation(r.graphqlError.message, {
                        fileName: r.fileName,
                        content: r.templateNode.getSourceFile().getFullText(),
                        start,
                        end: start + 1,
                    }));
                }
            }
        });
        return errors;
    }
    getDominantDefinition(result) {
        let type;
        const definedFragmentNames = [];
        const referencedFragmentNames = [];
        let operationName;
        (0, language_1.visit)(result.documentNode, {
            FragmentDefinition(node) {
                if (!type) {
                    type = 'fragment';
                }
                definedFragmentNames.push(node.name.value);
            },
            FragmentSpread(node) {
                referencedFragmentNames.push(node.name.value);
            },
            OperationDefinition(node) {
                if (!type || type === 'fragment') {
                    type = node.operation;
                }
                else {
                    type = 'complex';
                }
                if (!operationName) {
                    operationName = node.name ? node.name.value : 'ANONYMOUS_QUERY';
                }
                else {
                    operationName = 'MULTIPLE_OPERATIONS';
                }
            },
        });
        const noReferedFragmentNames = definedFragmentNames.filter(defName => referencedFragmentNames.every(n => defName !== n));
        return { type, operationName, fragmentName: noReferedFragmentNames[noReferedFragmentNames.length - 1] };
    }
    toManifest(extractResults, tagName = '') {
        const documents = extractResults
            .filter(r => !!r.documentNode)
            .map(result => {
            const r = result;
            const { type, operationName, fragmentName } = this.getDominantDefinition(r);
            return {
                fileName: r.fileName,
                type: type || 'other',
                operationName,
                fragmentName,
                body: (0, graphql_1.print)(r.documentNode),
                tag: tagName,
                templateLiteralNodeStart: this._helper.getLineAndChar(r.fileName, r.templateNode.getStart()),
                templateLiteralNodeEnd: this._helper.getLineAndChar(r.fileName, r.templateNode.getEnd()),
                documentStart: this._helper.getLineAndChar(r.fileName, r.templateNode.getStart() + 1),
                documentEnd: this._helper.getLineAndChar(r.fileName, r.templateNode.getEnd() - 1),
            };
        });
        return {
            documents,
        };
    }
}
exports.Extractor = Extractor;
//# sourceMappingURL=extractor.js.map