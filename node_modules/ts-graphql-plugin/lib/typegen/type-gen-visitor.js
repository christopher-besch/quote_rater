"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeGenVisitor = exports.TypeGenError = void 0;
const typescript_1 = __importDefault(require("typescript"));
const graphql_1 = require("graphql");
const language_1 = require("graphql/language");
class Stack {
    constructor(_initializer) {
        this._initializer = _initializer;
        this._array = [];
    }
    get current() {
        if (!this._array.length) {
            throw new Error('Invalid stack state.');
        }
        return this._array[this._array.length - 1];
    }
    stack(value) {
        if (value === undefined && this._initializer) {
            this._array.push(this._initializer());
            return this;
        }
        else if (value !== undefined) {
            this._array.push(value);
            return this;
        }
        else {
            throw new Error();
        }
    }
    consume() {
        const current = this.current;
        this._array.pop();
        return current;
    }
    get isEmpty() {
        return this._array.length === 0;
    }
}
class StructureStack extends Stack {
}
class TypeGenError extends Error {
    constructor(message, node) {
        super(message);
        this.message = message;
        this.node = node;
    }
}
exports.TypeGenError = TypeGenError;
class TypeGenVisitor {
    constructor({ schema }) {
        this._schema = schema;
    }
    visit(documentNode, { outputSource, addon }) {
        const parentTypeStack = new Stack();
        const resultFieldElementStack = new Stack(() => ({
            members: [],
            typeFragments: [],
        }));
        const variableElementStack = new Stack(() => ({
            members: [],
            typeFragments: [],
        }));
        const fieldMetadataMap = new Map();
        const fragmentMap = new Map();
        documentNode.definitions.forEach(def => {
            if (def.kind === 'FragmentDefinition') {
                fragmentMap.set(def.name.value, def);
            }
        });
        const processedInputObjectSet = new WeakSet();
        (0, language_1.visit)(documentNode, {
            OperationDefinition: {
                enter: node => {
                    if (node.operation === 'query') {
                        const queryType = this._schema.getQueryType();
                        if (!queryType) {
                            throw new TypeGenError(`Schema does not have Query type.`, node);
                        }
                        parentTypeStack.stack(queryType);
                        resultFieldElementStack.stack();
                    }
                    else if (node.operation === 'mutation') {
                        const mutationType = this._schema.getMutationType();
                        if (!mutationType) {
                            throw new TypeGenError(`Schema does not have Mutation type.`, node);
                        }
                        parentTypeStack.stack(mutationType);
                        resultFieldElementStack.stack();
                    }
                    else if (node.operation === 'subscription') {
                        const subscriptionType = this._schema.getSubscriptionType();
                        if (!subscriptionType) {
                            throw new TypeGenError(`Schema does not have Subscription type.`, node);
                        }
                        parentTypeStack.stack(subscriptionType);
                        resultFieldElementStack.stack();
                    }
                    variableElementStack.stack();
                },
                leave: node => {
                    const tsResultNode = this._createTsTypeDeclaration(node.name ? node.name.value : 'QueryResult', resultFieldElementStack.consume());
                    outputSource.pushStatement(tsResultNode);
                    const tsVariableNode = this._createTsTypeDeclaration(node.name ? node.name.value + 'Variables' : 'QueryVariables', variableElementStack.consume());
                    outputSource.pushStatement(tsVariableNode);
                    const operationType = parentTypeStack.consume();
                    addon.operationDefinition({ graqhqlNode: node, operationType, tsResultNode, tsVariableNode });
                },
            },
            VariableDefinition: {
                leave: node => {
                    const { typeNode: { name: { value: inputTypeName }, }, structureStack, } = this._getFieldMetadataFromTypeNode(node.type);
                    const variableType = this._schema.getType(inputTypeName);
                    if (!variableType) {
                        throw new TypeGenError(`Schema does not have InputType "${inputTypeName}".`, node);
                    }
                    const visitVariableType = (name, variableType, structureStack, optional) => {
                        let typeNode;
                        if (variableType instanceof graphql_1.GraphQLScalarType) {
                            typeNode = this._createTsTypeNodeFromScalar(variableType, addon);
                        }
                        else if (variableType instanceof graphql_1.GraphQLEnumType) {
                            typeNode = this._createTsTypeNodeFromEnum(variableType);
                        }
                        else if (variableType instanceof graphql_1.GraphQLInputObjectType) {
                            const tsTypeRefName = variableType.name + 'InputType';
                            if (!processedInputObjectSet.has(variableType)) {
                                processedInputObjectSet.add(variableType);
                                variableElementStack.stack();
                                Object.entries(variableType.getFields()).forEach(([fieldName, v]) => {
                                    const { fieldType, structureStack } = this._getFieldMetadataFromFieldTypeInstance(v);
                                    visitVariableType(fieldName, fieldType, structureStack, false);
                                });
                                const declaration = this._createTsTypeDeclaration(tsTypeRefName, variableElementStack.consume(), false);
                                outputSource.pushStatement(declaration);
                            }
                            typeNode = typescript_1.default.createTypeReferenceNode(tsTypeRefName, undefined);
                        }
                        if (!typeNode) {
                            throw new Error('Unknown variable input type. ' + variableType.toJSON());
                        }
                        const { node: tn, lastStructureKind } = this._wrapTsTypeNodeWithStructualModifiers(typeNode, structureStack);
                        typeNode = tn;
                        variableElementStack.current.members.push(typescript_1.default.createPropertySignature(undefined, name, optional || lastStructureKind === 'null' ? typescript_1.default.createToken(typescript_1.default.SyntaxKind.QuestionToken) : undefined, typeNode, undefined));
                    };
                    visitVariableType(node.variable.name.value, variableType, structureStack, !!node.defaultValue);
                },
            },
            FragmentDefinition: {
                enter: node => {
                    const conditionNamedType = this._schema.getType(node.typeCondition.name.value);
                    parentTypeStack.stack(conditionNamedType);
                    resultFieldElementStack.stack();
                },
                leave: node => {
                    const conditionType = parentTypeStack.consume();
                    const tsNode = this._createTsTypeDeclaration(node.name.value, resultFieldElementStack.consume());
                    outputSource.pushStatement(tsNode);
                    addon.fragmentDefinition({ conditionType, graphqlNode: node, tsNode });
                },
            },
            FragmentSpread: {
                leave: node => {
                    const fragmentDefNode = fragmentMap.get(node.name.value);
                    const isUnionCondition = this._isConcreteTypeOfParentUnionType(fragmentDefNode.typeCondition, parentTypeStack.current);
                    resultFieldElementStack.current.typeFragments.push({
                        isUnionCondition,
                        typeNode: typescript_1.default.createTypeReferenceNode(node.name.value, undefined),
                    });
                },
            },
            InlineFragment: {
                enter: node => {
                    if (!node.typeCondition)
                        return;
                    const conditionNamedType = this._schema.getType(node.typeCondition.name.value);
                    parentTypeStack.stack(conditionNamedType);
                    resultFieldElementStack.stack();
                },
                leave: node => {
                    if (!node.typeCondition)
                        return;
                    parentTypeStack.consume();
                    const typeNode = this._createTsFieldTypeNode(resultFieldElementStack.consume());
                    const isUnionCondition = this._isConcreteTypeOfParentUnionType(node.typeCondition, parentTypeStack.current);
                    resultFieldElementStack.current.typeFragments.push({
                        isUnionCondition,
                        typeNode,
                    });
                },
            },
            Field: {
                enter: node => {
                    if (node.name.value === '__typename')
                        return;
                    if (parentTypeStack.current instanceof graphql_1.GraphQLUnionType) {
                        throw new TypeGenError("Selections can't be made directly on unions.", node);
                    }
                    const field = parentTypeStack.current.getFields()[node.name.value];
                    if (!field) {
                        throw new TypeGenError(`Type "${parentTypeStack.current.name}" does not have field "${node.name.value}".`, node);
                    }
                    const fieldMetadata = this._getFieldMetadataFromFieldTypeInstance(field);
                    if (fieldMetadata.fieldType instanceof graphql_1.GraphQLObjectType ||
                        fieldMetadata.fieldType instanceof graphql_1.GraphQLInterfaceType ||
                        fieldMetadata.fieldType instanceof graphql_1.GraphQLUnionType) {
                        parentTypeStack.stack(fieldMetadata.fieldType);
                        resultFieldElementStack.stack();
                    }
                    fieldMetadataMap.set(node, fieldMetadata);
                },
                leave: node => {
                    if (node.name.value === '__typename') {
                        resultFieldElementStack.current.members.push(this._createTsDoubleUnderscoreTypenameFieldType(parentTypeStack.current));
                        return;
                    }
                    const { fieldType, structureStack } = fieldMetadataMap.get(node);
                    let typeNode;
                    if (fieldType instanceof graphql_1.GraphQLScalarType) {
                        typeNode = this._createTsTypeNodeFromScalar(fieldType, addon);
                    }
                    else if (fieldType instanceof graphql_1.GraphQLEnumType) {
                        typeNode = this._createTsTypeNodeFromEnum(fieldType);
                    }
                    else if (fieldType instanceof graphql_1.GraphQLObjectType ||
                        fieldType instanceof graphql_1.GraphQLInterfaceType ||
                        fieldType instanceof graphql_1.GraphQLUnionType) {
                        typeNode = this._createTsFieldTypeNode(resultFieldElementStack.consume());
                        parentTypeStack.consume();
                    }
                    if (!typeNode) {
                        throw new Error('Unknown field output type. ' + fieldType.toJSON());
                    }
                    typeNode = this._wrapTsTypeNodeWithStructualModifiers(typeNode, structureStack).node;
                    resultFieldElementStack.current.members.push(typescript_1.default.createPropertySignature(undefined, node.alias ? node.alias.value : node.name.value, undefined, typeNode, undefined));
                    fieldMetadataMap.delete(node);
                },
            },
        });
        addon.document({ graphqlNode: documentNode });
        outputSource.writeLeadingComment('eslint-disable');
        outputSource.writeLeadingComment('This is an autogenerated file. Do not edit this file directly!');
        return outputSource.toSourceFile();
    }
    _getFieldMetadataFromFieldTypeInstance(field) {
        let fieldType = field.type;
        const structureStack = new StructureStack().stack('null');
        while (fieldType instanceof graphql_1.GraphQLNonNull || fieldType instanceof graphql_1.GraphQLList) {
            if (fieldType instanceof graphql_1.GraphQLList) {
                structureStack.stack('list').stack('null');
            }
            else if (fieldType instanceof graphql_1.GraphQLNonNull) {
                structureStack.consume();
            }
            fieldType = fieldType.ofType;
        }
        return {
            fieldType: fieldType,
            structureStack,
        };
    }
    _getFieldMetadataFromTypeNode(node) {
        let typeNode = node;
        const structureStack = new StructureStack().stack('null');
        while (typeNode.kind !== 'NamedType') {
            if (typeNode.kind === 'ListType') {
                structureStack.stack('list').stack('null');
            }
            else if (typeNode.kind === 'NonNullType') {
                structureStack.consume();
            }
            typeNode = typeNode.type;
        }
        return { typeNode, structureStack };
    }
    _isConcreteTypeOfParentUnionType(typeCondition, parentType) {
        if (parentType instanceof graphql_1.GraphQLUnionType) {
            const unionElementTypes = parentType.getTypes();
            return unionElementTypes.some(ut => ut.name === typeCondition.name.value);
        }
        else {
            return false;
        }
    }
    _wrapTsTypeNodeWithStructualModifiers(typeNode, structureStack) {
        let node = typeNode;
        let kind = undefined;
        while (!structureStack.isEmpty) {
            kind = structureStack.consume();
            node =
                kind === 'null'
                    ? typescript_1.default.createUnionTypeNode([
                        node,
                        typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NullKeyword),
                    ])
                    : kind === 'list'
                        ? typescript_1.default.createArrayTypeNode(node)
                        : node;
        }
        return { node, lastStructureKind: kind };
    }
    _createTsTypeNodeFromEnum(fieldType) {
        return typescript_1.default.createUnionTypeNode(fieldType.getValues().map(v => typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(v.value))));
    }
    _createTsDoubleUnderscoreTypenameFieldType(parentType) {
        if (parentType instanceof graphql_1.GraphQLObjectType) {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(parentType.name)), undefined);
        }
        else if (parentType instanceof graphql_1.GraphQLUnionType) {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createUnionTypeNode(parentType.getTypes().map(t => typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(t.name)))), undefined);
        }
        else {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword), undefined);
        }
    }
    _createTsTypeNodeFromScalar(fieldType, addon) {
        const typeNode = addon.customScalar({ scalarType: fieldType });
        if (typeNode)
            return typeNode;
        switch (fieldType.name) {
            case 'Boolean':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.BooleanKeyword);
            case 'String':
            case 'ID':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword);
            case 'Int':
            case 'Float':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NumberKeyword);
            default:
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword);
        }
    }
    _createTsTypeDeclaration(name, fieldTypeElement, shouldExport = true) {
        const modifiers = shouldExport ? typescript_1.default.createModifiersFromModifierFlags(typescript_1.default.ModifierFlags.Export) : undefined;
        return typescript_1.default.createTypeAliasDeclaration(undefined, modifiers, name, undefined, this._createTsFieldTypeNode(fieldTypeElement));
    }
    _createTsFieldTypeNode({ members, typeFragments }) {
        if (!members.length && !typeFragments.length) {
            return typescript_1.default.createTypeLiteralNode(undefined);
        }
        const toUnionElements = [];
        const toIntersectionElements = [];
        typeFragments.forEach(({ isUnionCondition, typeNode }) => {
            if (isUnionCondition) {
                toUnionElements.push(typeNode);
            }
            else {
                toIntersectionElements.push(typeNode);
            }
        });
        if (toUnionElements.length) {
            toIntersectionElements.push(typescript_1.default.createUnionTypeNode(toUnionElements));
        }
        if (members.length) {
            toIntersectionElements.unshift(typescript_1.default.createTypeLiteralNode(members));
        }
        return typescript_1.default.createIntersectionTypeNode(toIntersectionElements);
    }
}
exports.TypeGenVisitor = TypeGenVisitor;
//# sourceMappingURL=type-gen-visitor.js.map